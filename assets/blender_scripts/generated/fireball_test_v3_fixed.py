#!/usr/bin/env python3
"""
GPT-5.2 â€” Fireball Test V3 (OpenVDB) - Blender 5.0+

Generated by PlasmaDXR Script Generator
Date: 2025-12-25
Template: built-in explosion

Description:
    A dramatic fireball explosion with bright orange flames and billowing smoke

Usage:
    blender --background --python fireball_test_v3.py -- [options]

Options:
    --resolution INT    Simulation resolution (default: 96)
    --frame_start INT   Start frame (default: 1)
    --frame_end INT     End frame (default: 50)
    --output_dir PATH   Output directory for VDB files
    --bake BOOL         Run bake (1) or skip (0)
    --render BOOL       Render preview images (1) or skip (0)
    --render_frames STR Frames to render: "mid", "all", or "1,25,50" (default: mid)
"""

import bpy
import sys
import os
from pathlib import Path

# =============================================================================
# Configuration
# =============================================================================

class Config:
    """Script configuration - modify these values or pass via command line."""

    RESOLUTION = 96
    FRAME_START = 1
    FRAME_END = 50
    OUTPUT_DIR = "/home/maz3ppa/projects/PlasmaDXR/build/vdb_output/fireball_test_v3"
    BAKE = True
    RENDER = True  # Enable preview rendering for evaluation
    RENDER_FRAMES = "mid"  # "mid", "all", or comma-separated frame numbers

    # Render settings for evaluation
    RENDER_RESOLUTION_X = 512
    RENDER_RESOLUTION_Y = 512
    RENDER_SAMPLES = 64  # Cycles samples (lower for speed)

    # Domain settings
    DOMAIN_SCALE = 4.0

    # Simulation settings
    # Effect: explosion
    # A dramatic fireball explosion with bright orange f...


def parse_args():
    """Parse command line arguments after '--'."""
    argv = sys.argv
    if "--" in argv:
        argv = argv[argv.index("--") + 1:]
    else:
        argv = []

    i = 0
    while i < len(argv):
        arg = argv[i]
        if arg == "--resolution" and i + 1 < len(argv):
            Config.RESOLUTION = int(argv[i + 1])
            i += 2
        elif arg == "--frame_start" and i + 1 < len(argv):
            Config.FRAME_START = int(argv[i + 1])
            i += 2
        elif arg == "--frame_end" and i + 1 < len(argv):
            Config.FRAME_END = int(argv[i + 1])
            i += 2
        elif arg == "--output_dir" and i + 1 < len(argv):
            Config.OUTPUT_DIR = argv[i + 1]
            i += 2
        elif arg == "--bake" and i + 1 < len(argv):
            Config.BAKE = argv[i + 1].lower() in ("1", "true", "yes")
            i += 2
        elif arg == "--render" and i + 1 < len(argv):
            Config.RENDER = argv[i + 1].lower() in ("1", "true", "yes")
            i += 2
        elif arg == "--render_frames" and i + 1 < len(argv):
            Config.RENDER_FRAMES = argv[i + 1]
            i += 2
        else:
            i += 1

parse_args()

# =============================================================================
# Scene Setup
# =============================================================================

def clear_scene():
    """Remove all objects from scene."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

def setup_scene():
    """Configure scene settings."""
    scene = bpy.context.scene
    scene.frame_start = Config.FRAME_START
    scene.frame_end = Config.FRAME_END
    scene.render.engine = 'CYCLES'
    scene.cycles.device = 'GPU'


# =============================================================================
# Domain Creation
# =============================================================================

def create_domain():
    """Create and configure fluid domain for explosion."""
    # Create domain cube
    bpy.ops.mesh.primitive_cube_add(size=Config.DOMAIN_SCALE, location=(0, 0, 0))
    domain = bpy.context.active_object
    domain.name = "FluidDomain"

    # Add fluid modifier
    bpy.ops.object.modifier_add(type='FLUID')
    domain.modifiers["Fluid"].fluid_type = 'DOMAIN'

    settings = domain.modifiers["Fluid"].domain_settings
    settings.domain_type = 'GAS'

    # Resolution
    settings.resolution_max = Config.RESOLUTION
    settings.use_adaptive_domain = True

    # Cache settings
    settings.cache_type = 'ALL'
    settings.cache_directory = Config.OUTPUT_DIR
    settings.cache_data_format = 'OPENVDB'

    # Gas behavior
    settings.burning_rate = 1.5
    settings.flame_smoke = 1.0
    settings.flame_vorticity = 0.8
    settings.flame_max_temp = 5.0

    # Add volumetric material for rendering
    add_volume_material(domain)

    return domain


def add_volume_material(domain):
    """Add Principled Volume shader for fire/smoke visualization."""
    mat = bpy.data.materials.new(name="FireSmokeMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links

    nodes.clear()

    volume = nodes.new('ShaderNodeVolumePrincipled')
    volume.location = (0, 0)
    volume.inputs['Color'].default_value = (1.0, 0.25, 0.02, 1.0)
    volume.inputs['Density'].default_value = 10.0
    volume.inputs['Anisotropy'].default_value = 0.3
    volume.inputs['Blackbody Intensity'].default_value = 8.0
    volume.inputs['Temperature'].default_value = 2200.0

    output = nodes.new('ShaderNodeOutputMaterial')
    output.location = (300, 0)

    links.new(volume.outputs['Volume'], output.inputs['Volume'])

    domain.data.materials.append(mat)
    print("[script] Volumetric material applied")


def setup_camera_and_lighting():
    """Add camera and lights for rendering."""
    bpy.ops.object.camera_add(location=(6, -6, 4))
    cam = bpy.context.active_object
    cam.name = "Camera"
    cam.rotation_euler = (1.1, 0, 0.8)
    bpy.context.scene.camera = cam

    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    sun = bpy.context.active_object
    sun.data.energy = 3.0


def create_emitter():
    """Create flow emitter for explosion."""
    # Create emitter geometry
    bpy.ops.mesh.primitive_uv_sphere_add(radius=1.0, location=(0, 0, 0))

    emitter = bpy.context.active_object
    emitter.name = "FlowEmitter"

    # Add fluid modifier as flow
    bpy.ops.object.modifier_add(type='FLUID')
    emitter.modifiers["Fluid"].fluid_type = 'FLOW'

    flow = emitter.modifiers["Fluid"].flow_settings
    flow.flow_type = 'BOTH'  # Fire AND smoke
    flow.flow_behavior = 'INFLOW'
    flow.flow_type = 'BOTH'  # Fire and smoke
    flow.fuel_amount = 3.0
    flow.temperature = 3.0

    # Hide emitter mesh in render
    emitter.hide_render = True

    return emitter


def setup_camera_and_lighting():
    """Add camera and lights for rendering."""
    # Camera
    bpy.ops.object.camera_add(location=(6, -6, 4))
    cam = bpy.context.active_object
    cam.name = "Camera"
    cam.rotation_euler = (1.1, 0, 0.8)
    bpy.context.scene.camera = cam

    # Sun light
    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    sun = bpy.context.active_object
    sun.data.energy = 3.0

    # Fill light
    bpy.ops.object.light_add(type='AREA', location=(-4, -4, 3))
    fill = bpy.context.active_object
    fill.data.energy = 100.0


# =============================================================================
# Baking & Export
# =============================================================================

def bake_simulation(domain):
    """Bake the fluid simulation."""
    print(f"[script] Baking simulation: frames {Config.FRAME_START}-{Config.FRAME_END}")
    print(f"[script] Resolution: {Config.RESOLUTION}")
    print(f"[script] Output: {Config.OUTPUT_DIR}")

    # Ensure output directory exists
    Path(Config.OUTPUT_DIR).mkdir(parents=True, exist_ok=True)

    # Select domain and bake
    bpy.context.view_layer.objects.active = domain
    domain.select_set(True)

    bpy.ops.fluid.bake_all()

    print("[script] Bake complete!")


# =============================================================================
# Rendering for Evaluation
# =============================================================================

def setup_render_settings():
    """Configure render settings for evaluation previews."""
    scene = bpy.context.scene

    # Use Cycles for volumetrics
    scene.render.engine = 'CYCLES'
    scene.cycles.device = 'GPU'
    scene.cycles.samples = Config.RENDER_SAMPLES

    # Resolution
    scene.render.resolution_x = Config.RENDER_RESOLUTION_X
    scene.render.resolution_y = Config.RENDER_RESOLUTION_Y
    scene.render.resolution_percentage = 100

    # Output format
    scene.render.image_settings.file_format = 'PNG'
    scene.render.image_settings.color_mode = 'RGBA'
    scene.render.image_settings.compression = 15

    # Transparent background for compositing flexibility
    scene.render.film_transparent = True

    print(f"[script] Render settings: {Config.RENDER_RESOLUTION_X}x{Config.RENDER_RESOLUTION_Y}, {Config.RENDER_SAMPLES} samples")


def get_frames_to_render():
    """Determine which frames to render based on Config.RENDER_FRAMES."""
    if Config.RENDER_FRAMES == "mid":
        mid = (Config.FRAME_START + Config.FRAME_END) // 2
        return [mid]
    elif Config.RENDER_FRAMES == "all":
        # Render every 10th frame for "all"
        step = max(1, (Config.FRAME_END - Config.FRAME_START) // 5)
        return list(range(Config.FRAME_START, Config.FRAME_END + 1, step))
    else:
        # Parse comma-separated frame numbers
        try:
            return [int(f.strip()) for f in Config.RENDER_FRAMES.split(",")]
        except ValueError:
            mid = (Config.FRAME_START + Config.FRAME_END) // 2
            return [mid]


def render_previews():
    """Render preview images for quality evaluation."""
    setup_render_settings()

    scene = bpy.context.scene
    output_dir = Path(Config.OUTPUT_DIR)
    output_dir.mkdir(parents=True, exist_ok=True)

    frames = get_frames_to_render()
    rendered_files = []

    print(f"[script] Rendering {len(frames)} preview frame(s): {frames}")

    for frame in frames:
        # Clamp frame to valid range
        frame = max(Config.FRAME_START, min(frame, Config.FRAME_END))

        scene.frame_set(frame)

        # Output path
        render_path = output_dir / f"render_{frame:04d}.png"
        scene.render.filepath = str(render_path)

        # Render
        print(f"[script] Rendering frame {frame}...")
        bpy.ops.render.render(write_still=True)

        rendered_files.append(str(render_path))
        print(f"[script] Saved: {render_path}")

    print(f"[script] Rendered {len(rendered_files)} preview(s)")
    return rendered_files


# =============================================================================
# Main
# =============================================================================

def main():
    print("=" * 60)
    print("Fireball Test V3")
    print("=" * 60)

    clear_scene()
    setup_scene()

    domain = create_domain()
    emitter = create_emitter()
    setup_camera_and_lighting()

    if Config.BAKE:
        bake_simulation(domain)
    else:
        print("[script] Skipping bake (--bake 0)")

    # Render preview images for evaluation
    if Config.RENDER:
        render_previews()
    else:
        print("[script] Skipping render (--render 0)")

    # Save blend file
    blend_path = Path(Config.OUTPUT_DIR) / "fireball_test_v3.blend"
    bpy.ops.wm.save_as_mainfile(filepath=str(blend_path))
    print(f"[script] Saved: {blend_path}")


if __name__ == "__main__":
    main()
