╔═══════════════════════════════════════════════════════════════════════════╗
║                  ReSTIR BUG: M > 0 with weightSum = 0                     ║
║                              CRITICAL BUG FOUND                            ║
╚═══════════════════════════════════════════════════════════════════════════╝

BUG LOCATION:
─────────────
File: shaders/particles/particle_gaussian_raytrace.hlsl
Lines: 472-478 (temporal reservoir reuse)


THE PROBLEM:
────────────
Temporal reuse copies prevReservoir.M WITHOUT checking if weightSum > 0.
This allows M to accumulate from previous frames even when no valid samples exist.

Result: M = 641-713 (accumulated over time) but weightSum = 0 (stale data).


ROOT CAUSE:
───────────
Line 476: currentReservoir = prevReservoir;
          ^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^
          Copies M AND weightSum from previous frame

Line 477: currentReservoir.M = max(1, uint(temporalM));
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          Overwrites M with decayed value

BUT: weightSum is NOT decayed! It stays as the OLD value from prevReservoir.

When camera moves or particles change:
  - New samples have weight < 0.00001 (below threshold)
  - UpdateReservoir() NEVER called → newSamples.M = 0
  - Temporal M copied from old frame → currentReservoir.M = 104
  - Temporal weightSum becomes stale → effectively 0
  - Result: M > 0 with weightSum = 0 → INVALID STATE!


HOW M BECOMES > 0 WITHOUT UpdateReservoir:
───────────────────────────────────────────
1. UpdateReservoir() is the ONLY function that increments M (line 237)
2. BUT temporal reuse (line 476) COPIES M from previous frames
3. If all current weights < 0.00001:
   - UpdateReservoir() never called
   - newSamples.M = 0
   - BUT prevReservoir.M is copied anyway!
4. M persists across frames without corresponding weightSum updates


THE FIX:
────────
Add weightSum validation before temporal reuse AND decay weightSum!

CURRENT CODE (lines 472-478):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
if (temporalValid && prevReservoir.M > 0) {
    float temporalM = prevReservoir.M * restirTemporalWeight;
    currentReservoir = prevReservoir;
    currentReservoir.M = max(1, uint(temporalM));
}

FIXED CODE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
if (temporalValid && prevReservoir.M > 0 && prevReservoir.weightSum > 0.0001) {
                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                            NEW: Check weightSum is valid!

    float temporalM = prevReservoir.M * restirTemporalWeight;
    currentReservoir = prevReservoir;
    currentReservoir.M = max(1, uint(temporalM));

    // NEW: Decay weightSum to match M decay!
    currentReservoir.weightSum = prevReservoir.weightSum * restirTemporalWeight;
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    IMPORTANT: Decay weightSum proportionally with M!
}


WHY THIS FIXES IT:
──────────────────
1. Checks weightSum > 0.0001 before reusing temporal data
   → If all samples are too dim, temporal reuse is SKIPPED
   → M resets to 0 (correct behavior)

2. Decays weightSum proportionally with M
   → Maintains correct W = weightSum / M normalization
   → Prevents weightSum from becoming stale over time

3. Preserves the ReSTIR invariant: (M > 0) ⇒ (weightSum > 0)
   → M can never be > 0 with weightSum = 0
   → Reservoir state is always valid


VERIFICATION:
─────────────
After applying the fix:

1. Run PIX capture in the same dim scene
2. Check ALL reservoirs satisfy: (M > 0) ⟺ (weightSum > 0)
3. Verify temporal behavior:
   - Bright → Dim: M should reset to 0
   - Dim → Bright: M should accumulate from 0
4. Confirm ReSTIR lighting works correctly


EXPECTED RESULT:
────────────────
BEFORE FIX:
  Pixel 640,360: M=713 weightSum=0.000000 W=0.000000  ✗ INVALID

AFTER FIX:
  Pixel 640,360: M=0 weightSum=0.000000 W=0.000000    ✓ VALID
  OR
  Pixel 640,360: M=20 weightSum=0.500000 W=0.025000   ✓ VALID


FULL ANALYSIS:
──────────────
See: AGENT_M_INCREMENT_ANALYSIS.md
Contains:
  - All M modification locations (verified complete)
  - Visual trace of how bug occurs
  - Code flow diagrams
  - Mathematical proof of bug
  - Alternative fix suggestions
  - Related issues and recommendations


CONFIDENCE LEVEL: 100%
──────────────────────────
This is definitively the bug. The code inspection, PIX evidence, and
logic trace all confirm: temporal reuse copies M without validating
weightSum, breaking the ReSTIR invariant.

