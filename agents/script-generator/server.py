#!/usr/bin/env python3
"""
Script Generator MCP Server

Generates and modifies Blender Python scripts for NanoVDB asset creation.
Uses templates from working scripts and incorporates evaluation feedback.

Part of the Self-Improving NanoVDB Asset Generation Pipeline.

Tools:
    - generate_script: Create new Blender script from description
    - modify_script: Improve script based on evaluation feedback
    - analyze_script: Understand what a script does
    - list_templates: Show available template scripts
    - get_template: Get content of a template script

Usage:
    python server.py  # Run as MCP server (stdio transport)
"""

import json
import os
import re
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any

from dotenv import load_dotenv
from mcp.server.fastmcp import FastMCP

# Load environment
load_dotenv()

# Project paths
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = Path(os.getenv(
    "PROJECT_ROOT",
    SCRIPT_DIR.parent.parent
))

# Script directories
TEMPLATE_DIR = PROJECT_ROOT / "assets/blender_scripts/GPT-5.2"
OUTPUT_DIR = PROJECT_ROOT / "assets/blender_scripts/generated"

# Blender path for script headers
BLENDER_PATH = "/home/maz3ppa/apps/blender-5.0.1-linux-x64/blender"

# Create FastMCP server
mcp = FastMCP("script-generator")


# =============================================================================
# Data Classes
# =============================================================================

@dataclass
class ScriptAnalysis:
    """Analysis of a Blender script."""
    script_path: str
    script_type: str  # "pyro", "liquid", "mesh", "shader", "utility"
    domain_type: Optional[str]  # "GAS", "LIQUID", None
    features: List[str]  # ["mantaflow", "openvdb_export", "animation", etc.]
    parameters: Dict[str, Any]  # Extracted configurable parameters
    frame_range: Optional[tuple]
    resolution: Optional[int]
    output_format: str  # "openvdb", "blend", "render"
    summary: str


@dataclass
class GeneratedScript:
    """Result of script generation."""
    success: bool
    script_path: str
    script_content: str
    template_used: Optional[str]
    parameters: Dict[str, Any]
    notes: List[str]


@dataclass
class ScriptModification:
    """Result of script modification."""
    success: bool
    original_path: str
    modified_path: str
    changes_made: List[str]
    parameters_changed: Dict[str, Any]


# =============================================================================
# Script Templates
# =============================================================================

# Common script header template
SCRIPT_HEADER = '''#!/usr/bin/env python3
"""
{title}

Generated by PlasmaDXR Script Generator
Date: {date}
Template: {template}

Description:
    {description}

Usage:
    blender --background --python {filename} -- [options]

Options:
    --resolution INT    Simulation resolution (default: {resolution})
    --frame_start INT   Start frame (default: {frame_start})
    --frame_end INT     End frame (default: {frame_end})
    --output_dir PATH   Output directory for VDB files
    --bake BOOL         Run bake (1) or skip (0)
    --render BOOL       Render preview images (1) or skip (0)
    --render_frames STR Frames to render: "mid", "all", or "1,25,50" (default: mid)
"""

import bpy
import sys
import os
from pathlib import Path

# =============================================================================
# Configuration
# =============================================================================

class Config:
    """Script configuration - modify these values or pass via command line."""

    RESOLUTION = {resolution}
    FRAME_START = {frame_start}
    FRAME_END = {frame_end}
    OUTPUT_DIR = "{output_dir}"
    BAKE = True
    RENDER = True  # Enable preview rendering for evaluation
    RENDER_FRAMES = "mid"  # "mid", "all", or comma-separated frame numbers

    # Render settings for evaluation
    RENDER_RESOLUTION_X = 512
    RENDER_RESOLUTION_Y = 512
    RENDER_SAMPLES = 64  # Cycles samples (lower for speed)

    # Domain settings
    DOMAIN_SCALE = {domain_scale}

    # Simulation settings
{simulation_settings}


def parse_args():
    """Parse command line arguments after '--'."""
    argv = sys.argv
    if "--" in argv:
        argv = argv[argv.index("--") + 1:]
    else:
        argv = []

    i = 0
    while i < len(argv):
        arg = argv[i]
        if arg == "--resolution" and i + 1 < len(argv):
            Config.RESOLUTION = int(argv[i + 1])
            i += 2
        elif arg == "--frame_start" and i + 1 < len(argv):
            Config.FRAME_START = int(argv[i + 1])
            i += 2
        elif arg == "--frame_end" and i + 1 < len(argv):
            Config.FRAME_END = int(argv[i + 1])
            i += 2
        elif arg == "--output_dir" and i + 1 < len(argv):
            Config.OUTPUT_DIR = argv[i + 1]
            i += 2
        elif arg == "--bake" and i + 1 < len(argv):
            Config.BAKE = argv[i + 1].lower() in ("1", "true", "yes")
            i += 2
        elif arg == "--render" and i + 1 < len(argv):
            Config.RENDER = argv[i + 1].lower() in ("1", "true", "yes")
            i += 2
        elif arg == "--render_frames" and i + 1 < len(argv):
            Config.RENDER_FRAMES = argv[i + 1]
            i += 2
        else:
            i += 1

parse_args()
'''

# Pyro (smoke/fire) domain template
PYRO_DOMAIN_TEMPLATE = '''
# =============================================================================
# Scene Setup
# =============================================================================

def clear_scene():
    """Remove all objects from scene."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

def setup_scene():
    """Configure scene settings."""
    scene = bpy.context.scene
    scene.frame_start = Config.FRAME_START
    scene.frame_end = Config.FRAME_END
    scene.render.engine = 'CYCLES'
    scene.cycles.device = 'GPU'


# =============================================================================
# Domain Creation
# =============================================================================

def create_domain():
    """Create and configure fluid domain for {effect_type}."""
    # Create domain cube
    bpy.ops.mesh.primitive_cube_add(size=Config.DOMAIN_SCALE, location=(0, 0, 0))
    domain = bpy.context.active_object
    domain.name = "FluidDomain"

    # Add fluid modifier
    bpy.ops.object.modifier_add(type='FLUID')
    domain.modifiers["Fluid"].fluid_type = 'DOMAIN'

    settings = domain.modifiers["Fluid"].domain_settings
    settings.domain_type = 'GAS'

    # Resolution
    settings.resolution_max = Config.RESOLUTION
    settings.use_adaptive_domain = True

    # Cache settings
    settings.cache_type = 'ALL'
    settings.cache_directory = Config.OUTPUT_DIR
    settings.cache_data_format = 'OPENVDB'

    # Gas behavior
{gas_settings}

    # Add volumetric material for rendering
    add_volume_material(domain)

    return domain


def add_volume_material(domain):
    """Add Principled Volume shader for fire/smoke visualization."""
    mat = bpy.data.materials.new(name="FireSmokeMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links

    nodes.clear()

    volume = nodes.new('ShaderNodeVolumePrincipled')
    volume.location = (0, 0)
    # Aggressive settings for visible, dramatic fire/smoke
    volume.inputs['Color'].default_value = (1.0, 0.3, 0.05, 1.0)  # Rich orange
    volume.inputs['Density'].default_value = 10.0    # High density for thick smoke
    volume.inputs['Anisotropy'].default_value = 0.5  # Forward scattering
    volume.inputs['Blackbody Intensity'].default_value = 8.0  # Intense flame glow
    volume.inputs['Temperature'].default_value = 2500.0  # Hot flames

    output = nodes.new('ShaderNodeOutputMaterial')
    output.location = (300, 0)

    links.new(volume.outputs['Volume'], output.inputs['Volume'])

    domain.data.materials.append(mat)
    print("[script] Volumetric material applied (high density + emission)")


def setup_camera_and_lighting():
    """Add camera and lights for rendering."""
    bpy.ops.object.camera_add(location=(6, -6, 4))
    cam = bpy.context.active_object
    cam.name = "Camera"
    cam.rotation_euler = (1.1, 0, 0.8)
    bpy.context.scene.camera = cam

    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    sun = bpy.context.active_object
    sun.data.energy = 3.0


def create_emitter():
    """Create flow emitter for {effect_type}."""
    # Create emitter geometry
{emitter_geometry}

    emitter = bpy.context.active_object
    emitter.name = "FlowEmitter"

    # Add fluid modifier as flow
    bpy.ops.object.modifier_add(type='FLUID')
    emitter.modifiers["Fluid"].fluid_type = 'FLOW'

    flow = emitter.modifiers["Fluid"].flow_settings
    flow.flow_type = 'BOTH'  # Fire AND smoke
    flow.flow_behavior = 'INFLOW'
{flow_settings}

    # Hide emitter mesh in render
    emitter.hide_render = True

    return emitter


def setup_camera_and_lighting():
    """Add camera and lights for rendering."""
    # Camera
    bpy.ops.object.camera_add(location=(6, -6, 4))
    cam = bpy.context.active_object
    cam.name = "Camera"
    cam.rotation_euler = (1.1, 0, 0.8)
    bpy.context.scene.camera = cam

    # Sun light
    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    sun = bpy.context.active_object
    sun.data.energy = 3.0

    # Fill light
    bpy.ops.object.light_add(type='AREA', location=(-4, -4, 3))
    fill = bpy.context.active_object
    fill.data.energy = 100.0


# =============================================================================
# Baking & Export
# =============================================================================

def bake_simulation(domain):
    """Bake the fluid simulation."""
    print(f"[script] Baking simulation: frames {{Config.FRAME_START}}-{{Config.FRAME_END}}")
    print(f"[script] Resolution: {{Config.RESOLUTION}}")
    print(f"[script] Output: {{Config.OUTPUT_DIR}}")

    # Ensure output directory exists
    Path(Config.OUTPUT_DIR).mkdir(parents=True, exist_ok=True)

    # Select domain and bake
    bpy.context.view_layer.objects.active = domain
    domain.select_set(True)

    bpy.ops.fluid.bake_all()

    print("[script] Bake complete!")


# =============================================================================
# Rendering for Evaluation
# =============================================================================

def setup_render_settings():
    """Configure render settings for evaluation previews."""
    scene = bpy.context.scene

    # Use Cycles for volumetrics
    scene.render.engine = 'CYCLES'
    scene.cycles.device = 'GPU'
    scene.cycles.samples = Config.RENDER_SAMPLES

    # Resolution
    scene.render.resolution_x = Config.RENDER_RESOLUTION_X
    scene.render.resolution_y = Config.RENDER_RESOLUTION_Y
    scene.render.resolution_percentage = 100

    # Output format
    scene.render.image_settings.file_format = 'PNG'
    scene.render.image_settings.color_mode = 'RGBA'
    scene.render.image_settings.compression = 15

    # Transparent background for compositing flexibility
    scene.render.film_transparent = True

    print(f"[script] Render settings: {{Config.RENDER_RESOLUTION_X}}x{{Config.RENDER_RESOLUTION_Y}}, {{Config.RENDER_SAMPLES}} samples")


def get_frames_to_render():
    """Determine which frames to render based on Config.RENDER_FRAMES."""
    if Config.RENDER_FRAMES == "mid":
        mid = (Config.FRAME_START + Config.FRAME_END) // 2
        return [mid]
    elif Config.RENDER_FRAMES == "all":
        # Render every 10th frame for "all"
        step = max(1, (Config.FRAME_END - Config.FRAME_START) // 5)
        return list(range(Config.FRAME_START, Config.FRAME_END + 1, step))
    else:
        # Parse comma-separated frame numbers
        try:
            return [int(f.strip()) for f in Config.RENDER_FRAMES.split(",")]
        except ValueError:
            mid = (Config.FRAME_START + Config.FRAME_END) // 2
            return [mid]


def render_previews():
    """Render preview images for quality evaluation."""
    setup_render_settings()

    scene = bpy.context.scene
    output_dir = Path(Config.OUTPUT_DIR)
    output_dir.mkdir(parents=True, exist_ok=True)

    frames = get_frames_to_render()
    rendered_files = []

    print(f"[script] Rendering {{len(frames)}} preview frame(s): {{frames}}")

    for frame in frames:
        # Clamp frame to valid range
        frame = max(Config.FRAME_START, min(frame, Config.FRAME_END))

        scene.frame_set(frame)

        # Output path
        render_path = output_dir / f"render_{{frame:04d}}.png"
        scene.render.filepath = str(render_path)

        # Render
        print(f"[script] Rendering frame {{frame}}...")
        bpy.ops.render.render(write_still=True)

        rendered_files.append(str(render_path))
        print(f"[script] Saved: {{render_path}}")

    print(f"[script] Rendered {{len(rendered_files)}} preview(s)")
    return rendered_files


# =============================================================================
# Main
# =============================================================================

def main():
    print("=" * 60)
    print("{title}")
    print("=" * 60)

    clear_scene()
    setup_scene()

    domain = create_domain()
    emitter = create_emitter()
    setup_camera_and_lighting()

    if Config.BAKE:
        bake_simulation(domain)
    else:
        print("[script] Skipping bake (--bake 0)")

    # Render preview images for evaluation
    if Config.RENDER:
        render_previews()
    else:
        print("[script] Skipping render (--render 0)")

    # Save blend file
    blend_path = Path(Config.OUTPUT_DIR) / "{filename_stem}.blend"
    bpy.ops.wm.save_as_mainfile(filepath=str(blend_path))
    print(f"[script] Saved: {{blend_path}}")


if __name__ == "__main__":
    main()
'''

# Liquid domain template
LIQUID_DOMAIN_TEMPLATE = '''
# =============================================================================
# Scene Setup
# =============================================================================

def clear_scene():
    """Remove all objects from scene."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

def setup_scene():
    """Configure scene settings."""
    scene = bpy.context.scene
    scene.frame_start = Config.FRAME_START
    scene.frame_end = Config.FRAME_END


# =============================================================================
# Domain Creation
# =============================================================================

def create_domain():
    """Create and configure fluid domain for liquid simulation."""
    bpy.ops.mesh.primitive_cube_add(size=Config.DOMAIN_SCALE, location=(0, 0, 0))
    domain = bpy.context.active_object
    domain.name = "LiquidDomain"

    bpy.ops.object.modifier_add(type='FLUID')
    domain.modifiers["Fluid"].fluid_type = 'DOMAIN'

    settings = domain.modifiers["Fluid"].domain_settings
    settings.domain_type = 'LIQUID'

    settings.resolution_max = Config.RESOLUTION
    settings.use_mesh = True
    settings.mesh_scale = 1.0

    # Cache
    settings.cache_type = 'ALL'
    settings.cache_directory = Config.OUTPUT_DIR
    settings.cache_data_format = 'OPENVDB'

{liquid_settings}

    return domain


def create_inflow():
    """Create liquid inflow source."""
{inflow_geometry}

    inflow = bpy.context.active_object
    inflow.name = "LiquidInflow"

    bpy.ops.object.modifier_add(type='FLUID')
    inflow.modifiers["Fluid"].fluid_type = 'FLOW'

    flow = inflow.modifiers["Fluid"].flow_settings
    flow.flow_type = 'LIQUID'
    flow.flow_behavior = 'INFLOW'
{inflow_settings}

    return inflow


# =============================================================================
# Baking
# =============================================================================

def bake_simulation(domain):
    """Bake liquid simulation."""
    print(f"[script] Baking liquid: frames {{Config.FRAME_START}}-{{Config.FRAME_END}}")

    Path(Config.OUTPUT_DIR).mkdir(parents=True, exist_ok=True)

    bpy.context.view_layer.objects.active = domain
    domain.select_set(True)

    bpy.ops.fluid.bake_all()
    print("[script] Bake complete!")


# =============================================================================
# Rendering for Evaluation
# =============================================================================

def setup_render_settings():
    """Configure render settings for evaluation previews."""
    scene = bpy.context.scene

    # Use Cycles for volumetrics
    scene.render.engine = 'CYCLES'
    scene.cycles.device = 'GPU'
    scene.cycles.samples = Config.RENDER_SAMPLES

    # Resolution
    scene.render.resolution_x = Config.RENDER_RESOLUTION_X
    scene.render.resolution_y = Config.RENDER_RESOLUTION_Y
    scene.render.resolution_percentage = 100

    # Output format
    scene.render.image_settings.file_format = 'PNG'
    scene.render.image_settings.color_mode = 'RGBA'
    scene.render.image_settings.compression = 15

    print(f"[script] Render settings: {{Config.RENDER_RESOLUTION_X}}x{{Config.RENDER_RESOLUTION_Y}}, {{Config.RENDER_SAMPLES}} samples")


def get_frames_to_render():
    """Determine which frames to render based on Config.RENDER_FRAMES."""
    if Config.RENDER_FRAMES == "mid":
        mid = (Config.FRAME_START + Config.FRAME_END) // 2
        return [mid]
    elif Config.RENDER_FRAMES == "all":
        step = max(1, (Config.FRAME_END - Config.FRAME_START) // 5)
        return list(range(Config.FRAME_START, Config.FRAME_END + 1, step))
    else:
        try:
            return [int(f.strip()) for f in Config.RENDER_FRAMES.split(",")]
        except ValueError:
            mid = (Config.FRAME_START + Config.FRAME_END) // 2
            return [mid]


def render_previews():
    """Render preview images for quality evaluation."""
    setup_render_settings()

    scene = bpy.context.scene
    output_dir = Path(Config.OUTPUT_DIR)
    output_dir.mkdir(parents=True, exist_ok=True)

    frames = get_frames_to_render()
    rendered_files = []

    print(f"[script] Rendering {{len(frames)}} preview frame(s): {{frames}}")

    for frame in frames:
        frame = max(Config.FRAME_START, min(frame, Config.FRAME_END))
        scene.frame_set(frame)

        render_path = output_dir / f"render_{{frame:04d}}.png"
        scene.render.filepath = str(render_path)

        print(f"[script] Rendering frame {{frame}}...")
        bpy.ops.render.render(write_still=True)

        rendered_files.append(str(render_path))
        print(f"[script] Saved: {{render_path}}")

    print(f"[script] Rendered {{len(rendered_files)}} preview(s)")
    return rendered_files


def main():
    print("=" * 60)
    print("{title}")
    print("=" * 60)

    clear_scene()
    setup_scene()

    domain = create_domain()
    inflow = create_inflow()

    if Config.BAKE:
        bake_simulation(domain)
    else:
        print("[script] Skipping bake (--bake 0)")

    # Render preview images for evaluation
    if Config.RENDER:
        render_previews()
    else:
        print("[script] Skipping render (--render 0)")

    blend_path = Path(Config.OUTPUT_DIR) / "{filename_stem}.blend"
    bpy.ops.wm.save_as_mainfile(filepath=str(blend_path))
    print(f"[script] Saved: {{blend_path}}")


if __name__ == "__main__":
    main()
'''


# =============================================================================
# Helper Functions
# =============================================================================

def extract_script_info(content: str) -> Dict[str, Any]:
    """Extract information from a script's content."""
    info = {
        "domain_type": None,
        "resolution": None,
        "frame_range": None,
        "features": [],
        "parameters": {}
    }

    # Detect domain type
    if "domain_type = 'GAS'" in content or 'domain_type = "GAS"' in content:
        info["domain_type"] = "GAS"
        info["features"].append("pyro")
    elif "domain_type = 'LIQUID'" in content or 'domain_type = "LIQUID"' in content:
        info["domain_type"] = "LIQUID"
        info["features"].append("liquid")

    # Detect features
    if "OPENVDB" in content or "openvdb" in content.lower():
        info["features"].append("openvdb_export")
    if "animation" in content.lower() or "keyframe" in content.lower():
        info["features"].append("animation")
    if "noise" in content.lower():
        info["features"].append("procedural_noise")
    if "turbulence" in content.lower():
        info["features"].append("turbulence")

    # Extract resolution
    res_match = re.search(r'resolution_max\s*=\s*(\d+)', content)
    if res_match:
        info["resolution"] = int(res_match.group(1))

    # Extract frame range
    start_match = re.search(r'frame_start\s*=\s*(\d+)', content, re.IGNORECASE)
    end_match = re.search(r'frame_end\s*=\s*(\d+)', content, re.IGNORECASE)
    if start_match and end_match:
        info["frame_range"] = (int(start_match.group(1)), int(end_match.group(1)))

    return info


def determine_script_type(content: str, filename: str) -> str:
    """Determine the type of script from content and filename."""
    content_lower = content.lower()
    filename_lower = filename.lower()

    if "domain_type = 'gas'" in content_lower or "smoke" in filename_lower or "fire" in filename_lower or "explosion" in filename_lower:
        return "pyro"
    elif "domain_type = 'liquid'" in content_lower or "liquid" in filename_lower or "water" in filename_lower:
        return "liquid"
    elif "bpy.types.shader" in content_lower or "node_tree" in content_lower:
        return "shader"
    elif "bpy.ops.mesh" in content_lower and "modifier" not in content_lower:
        return "mesh"
    else:
        return "utility"


# =============================================================================
# MCP Tools
# =============================================================================

@mcp.tool()
async def list_templates(
    script_type: Optional[str] = None
) -> str:
    """
    List available template scripts.

    Args:
        script_type: Optional filter by type ("pyro", "liquid", "mesh", etc.)

    Returns:
        JSON array of template scripts with metadata

    Example:
        list_templates("pyro")  # List only pyro/explosion templates
    """
    templates = []

    if not TEMPLATE_DIR.exists():
        return json.dumps({"error": f"Template directory not found: {TEMPLATE_DIR}"})

    for script_path in TEMPLATE_DIR.rglob("*.py"):
        if "__pycache__" in str(script_path):
            continue

        try:
            content = script_path.read_text()
            detected_type = determine_script_type(content, script_path.name)

            # Apply filter
            if script_type and detected_type != script_type:
                continue

            # Extract docstring
            description = ""
            if content.startswith('"""') or content.startswith("'''"):
                quote = '"""' if content.startswith('"""') else "'''"
                end = content.find(quote, 3)
                if end > 0:
                    description = content[3:end].strip().split("\n")[0]

            info = extract_script_info(content)

            templates.append({
                "path": str(script_path.relative_to(PROJECT_ROOT)),
                "name": script_path.stem,
                "type": detected_type,
                "description": description[:100] if description else "",
                "domain_type": info["domain_type"],
                "resolution": info["resolution"],
                "features": info["features"]
            })
        except Exception as e:
            continue

    # Sort by type then name
    templates.sort(key=lambda x: (x["type"], x["name"]))

    return json.dumps({
        "count": len(templates),
        "filter": script_type,
        "templates": templates
    }, indent=2)


@mcp.tool()
async def get_template(
    template_name: str
) -> str:
    """
    Get the full content of a template script.

    Args:
        template_name: Name or path of template (e.g., "blender_hydrogen_cloud" or full path)

    Returns:
        JSON with script content and metadata

    Example:
        get_template("blender_explosion_grenade_bake")
    """
    # Find the template
    template_path = None

    # Check if it's a full path
    if "/" in template_name:
        template_path = PROJECT_ROOT / template_name
    else:
        # Search for it
        for script_path in TEMPLATE_DIR.rglob("*.py"):
            if script_path.stem == template_name or template_name in script_path.stem:
                template_path = script_path
                break

    if not template_path or not template_path.exists():
        return json.dumps({"error": f"Template not found: {template_name}"})

    content = template_path.read_text()
    info = extract_script_info(content)

    return json.dumps({
        "path": str(template_path.relative_to(PROJECT_ROOT)),
        "name": template_path.stem,
        "type": determine_script_type(content, template_path.name),
        "content": content,
        "info": info
    }, indent=2)


@mcp.tool()
async def analyze_script(
    script_path: str
) -> str:
    """
    Analyze a Blender script to understand its structure and parameters.

    Args:
        script_path: Path to script to analyze

    Returns:
        JSON with ScriptAnalysis containing type, features, parameters

    Example:
        analyze_script("assets/blender_scripts/GPT-5.2/blender_hydrogen_cloud.py")
    """
    path = Path(script_path)
    if not path.is_absolute():
        path = PROJECT_ROOT / script_path

    if not path.exists():
        return json.dumps({"error": f"Script not found: {path}"})

    content = path.read_text()
    info = extract_script_info(content)
    script_type = determine_script_type(content, path.name)

    # Extract docstring for summary
    summary = ""
    if content.startswith('"""') or content.startswith("'''"):
        quote = '"""' if content.startswith('"""') else "'''"
        end = content.find(quote, 3)
        if end > 0:
            docstring = content[3:end].strip()
            # Get first paragraph
            paras = docstring.split("\n\n")
            summary = paras[0].replace("\n", " ")[:200]

    # Determine output format
    output_format = "blend"
    if "OPENVDB" in content:
        output_format = "openvdb"
    elif "render" in content.lower():
        output_format = "render"

    result = ScriptAnalysis(
        script_path=str(path),
        script_type=script_type,
        domain_type=info["domain_type"],
        features=info["features"],
        parameters=info["parameters"],
        frame_range=info["frame_range"],
        resolution=info["resolution"],
        output_format=output_format,
        summary=summary
    )

    return json.dumps(asdict(result), indent=2)


@mcp.tool()
async def generate_script(
    effect_type: str,
    description: str,
    output_name: str,
    resolution: int = 96,
    frame_start: int = 1,
    frame_end: int = 50,
    template_name: Optional[str] = None
) -> str:
    """
    Generate a new Blender script from a description.

    Args:
        effect_type: Type of effect ("pyro", "liquid", "explosion", "nebula", etc.)
        description: Description of what to create
        output_name: Name for the output script (without .py)
        resolution: Simulation resolution (default 96)
        frame_start: Start frame (default 1)
        frame_end: End frame (default 50)
        template_name: Optional template to base on

    Returns:
        JSON with GeneratedScript containing path and content

    Example:
        generate_script(
            effect_type="pyro",
            description="A rising mushroom cloud explosion with bright orange fire",
            output_name="mushroom_cloud",
            resolution=128,
            frame_end=100
        )
    """
    # Ensure output directory exists
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    output_path = OUTPUT_DIR / f"{output_name}.py"
    notes = []

    # Determine base template
    if template_name:
        template_result = await get_template(template_name)
        template_data = json.loads(template_result)
        if "error" in template_data:
            notes.append(f"Template not found, using built-in: {template_name}")
            template_name = None

    # Select appropriate template based on effect type
    effect_lower = effect_type.lower()

    if effect_lower in ["pyro", "smoke", "fire", "explosion", "nebula", "gas"]:
        domain_template = PYRO_DOMAIN_TEMPLATE
        domain_type = "GAS"

        # Customize gas settings based on effect
        if "explosion" in effect_lower or "explosion" in description.lower():
            # Aggressive settings for visible, dramatic explosions
            gas_settings = """    settings.burning_rate = 1.5      # High burn rate for intense flames
    settings.flame_smoke = 1.0       # Maximum smoke from flames
    settings.flame_vorticity = 0.8   # Strong turbulent swirling
    settings.flame_max_temp = 5.0    # Very hot flames (bright yellow/white)
    settings.vorticity = 0.5         # Additional turbulence"""
            emitter_geometry = """    bpy.ops.mesh.primitive_uv_sphere_add(radius=1.0, location=(0, 0, 0))  # Larger emitter"""
            flow_settings = """    flow.flow_type = 'BOTH'  # Fire and smoke
    flow.fuel_amount = 3.0    # High fuel for dramatic flames
    flow.temperature = 3.0    # Hot initial temperature"""
        else:
            gas_settings = """    settings.vorticity = 0.1
    settings.dissolve_speed = 25
    settings.use_dissolve_smoke = True"""
            emitter_geometry = """    bpy.ops.mesh.primitive_ico_sphere_add(radius=0.3, location=(0, 0, -1))"""
            flow_settings = """    flow.flow_type = 'SMOKE'
    flow.smoke_color = (1.0, 0.8, 0.6)
    flow.temperature = 1.0"""

    elif effect_lower in ["liquid", "water", "fluid"]:
        domain_template = LIQUID_DOMAIN_TEMPLATE
        domain_type = "LIQUID"
        gas_settings = ""
        emitter_geometry = """    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.3, location=(0, 0, 1))"""
        flow_settings = """    flow.use_initial_velocity = True
    flow.velocity_factor = 1.0"""
    else:
        # Default to pyro
        domain_template = PYRO_DOMAIN_TEMPLATE
        domain_type = "GAS"
        gas_settings = """    settings.vorticity = 0.1"""
        emitter_geometry = """    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.5, location=(0, 0, 0))"""
        flow_settings = """    flow.flow_type = 'SMOKE'"""
        notes.append(f"Unknown effect type '{effect_type}', defaulting to pyro")

    # Build simulation settings for Config class
    sim_settings = f"""    # Effect: {effect_type}
    # {description[:50]}..."""

    # Determine domain scale based on effect type
    if effect_lower in ["explosion", "pyro"] or "explosion" in description.lower():
        domain_scale = 6.0  # Larger domain for explosive effects
    else:
        domain_scale = 4.0

    # Format the header
    header = SCRIPT_HEADER.format(
        title=f"GPT-5.2 â€” {output_name.replace('_', ' ').title()} (OpenVDB) - Blender 5.0+",
        date=datetime.now().strftime("%Y-%m-%d"),
        template=template_name or f"built-in {effect_type}",
        description=description,
        filename=f"{output_name}.py",
        resolution=resolution,
        frame_start=frame_start,
        frame_end=frame_end,
        output_dir=str(PROJECT_ROOT / "build/vdb_output" / output_name),
        domain_scale=domain_scale,
        simulation_settings=sim_settings
    )

    # Format the body
    body = domain_template.format(
        effect_type=effect_type,
        title=f"{output_name.replace('_', ' ').title()}",
        filename_stem=output_name,
        gas_settings=gas_settings,
        emitter_geometry=emitter_geometry,
        flow_settings=flow_settings,
        liquid_settings=gas_settings,
        inflow_geometry=emitter_geometry,
        inflow_settings=flow_settings
    )

    # Combine
    script_content = header + body

    # Write script
    output_path.write_text(script_content)
    notes.append(f"Generated {len(script_content)} bytes")

    result = GeneratedScript(
        success=True,
        script_path=str(output_path.relative_to(PROJECT_ROOT)),
        script_content=script_content,
        template_used=template_name,
        parameters={
            "effect_type": effect_type,
            "resolution": resolution,
            "frame_range": [frame_start, frame_end],
            "domain_type": domain_type
        },
        notes=notes
    )

    return json.dumps(asdict(result), indent=2)


@mcp.tool()
async def modify_script(
    script_path: str,
    modifications: Dict[str, Any],
    output_name: Optional[str] = None
) -> str:
    """
    Modify an existing script based on feedback or parameter changes.

    Args:
        script_path: Path to script to modify
        modifications: Dict of changes to make, can include:
            - resolution: New resolution value
            - frame_end: New end frame
            - turbulence: Turbulence/vorticity value (0-1)
            - density: Density multiplier
            - temperature: Temperature value
            - custom_code: Dict of {search_pattern: replacement}
        output_name: Optional new filename (default: adds "_modified" suffix)

    Returns:
        JSON with ScriptModification result

    Example:
        modify_script(
            "assets/blender_scripts/generated/mushroom_cloud.py",
            {
                "resolution": 128,
                "turbulence": 0.8,
                "frame_end": 150
            }
        )
    """
    path = Path(script_path)
    if not path.is_absolute():
        path = PROJECT_ROOT / script_path

    if not path.exists():
        return json.dumps({"error": f"Script not found: {path}"})

    content = path.read_text()
    changes_made = []
    params_changed = {}

    # Apply modifications
    if "resolution" in modifications:
        new_res = modifications["resolution"]
        content = re.sub(
            r'(resolution_max\s*=\s*)\d+',
            f'\\g<1>{new_res}',
            content
        )
        content = re.sub(
            r'(RESOLUTION\s*=\s*)\d+',
            f'\\g<1>{new_res}',
            content
        )
        changes_made.append(f"Resolution: {new_res}")
        params_changed["resolution"] = new_res

    if "frame_end" in modifications:
        new_end = modifications["frame_end"]
        content = re.sub(
            r'(frame_end\s*=\s*)\d+',
            f'\\g<1>{new_end}',
            content,
            flags=re.IGNORECASE
        )
        content = re.sub(
            r'(FRAME_END\s*=\s*)\d+',
            f'\\g<1>{new_end}',
            content
        )
        changes_made.append(f"Frame end: {new_end}")
        params_changed["frame_end"] = new_end

    if "frame_start" in modifications:
        new_start = modifications["frame_start"]
        content = re.sub(
            r'(frame_start\s*=\s*)\d+',
            f'\\g<1>{new_start}',
            content,
            flags=re.IGNORECASE
        )
        changes_made.append(f"Frame start: {new_start}")
        params_changed["frame_start"] = new_start

    if "turbulence" in modifications or "vorticity" in modifications:
        new_turb = modifications.get("turbulence", modifications.get("vorticity"))
        content = re.sub(
            r'(vorticity\s*=\s*)[\d.]+',
            f'\\g<1>{new_turb}',
            content
        )
        changes_made.append(f"Vorticity: {new_turb}")
        params_changed["vorticity"] = new_turb

    if "temperature" in modifications:
        new_temp = modifications["temperature"]
        content = re.sub(
            r'(temperature\s*=\s*)[\d.]+',
            f'\\g<1>{new_temp}',
            content
        )
        changes_made.append(f"Temperature: {new_temp}")
        params_changed["temperature"] = new_temp

    if "domain_scale" in modifications:
        new_scale = modifications["domain_scale"]
        content = re.sub(
            r'(DOMAIN_SCALE\s*=\s*)[\d.]+',
            f'\\g<1>{new_scale}',
            content
        )
        changes_made.append(f"Domain scale: {new_scale}")
        params_changed["domain_scale"] = new_scale

    # Custom code replacements
    if "custom_code" in modifications:
        for search, replace in modifications["custom_code"].items():
            if search in content:
                content = content.replace(search, replace)
                changes_made.append(f"Custom: {search[:30]}...")

    # Determine output path
    if output_name:
        output_path = OUTPUT_DIR / f"{output_name}.py"
    else:
        output_path = OUTPUT_DIR / f"{path.stem}_modified.py"

    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)

    result = ScriptModification(
        success=True,
        original_path=str(path.relative_to(PROJECT_ROOT)),
        modified_path=str(output_path.relative_to(PROJECT_ROOT)),
        changes_made=changes_made,
        parameters_changed=params_changed
    )

    return json.dumps(asdict(result), indent=2)


# =============================================================================
# Main
# =============================================================================

if __name__ == "__main__":
    mcp.run()
