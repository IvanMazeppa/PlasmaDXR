"""
Integration Tools
Create test scenarios, ImGui controls, and validate file syntax
"""

import json
from typing import Dict, List, Optional


async def create_test_scenario(
    name: str,
    particle_count: int,
    material_distribution: Dict[str, float],
    lighting_preset: str = "stellar_ring",
    camera_distance: float = 800.0,
    output_format: str = "json"
) -> str:
    """
    Generate test scenario configuration for material system validation

    Args:
        name: Scenario name (e.g., "gas_cloud_test")
        particle_count: Total number of particles
        material_distribution: Dict of material types to percentage (must sum to 1.0)
                               e.g., {"GAS_CLOUD": 0.3, "STAR": 0.2, "PLASMA": 0.5}
        lighting_preset: Light configuration (stellar_ring, dual_binary, etc.)
        camera_distance: Camera distance from origin (800.0 = good overview)
        output_format: Output format (json, markdown)

    Returns:
        Formatted test scenario configuration
    """

    # Validate distribution sums to 1.0
    total_distribution = sum(material_distribution.values())
    if abs(total_distribution - 1.0) > 0.01:
        return f"❌ Error: Material distribution sums to {total_distribution:.2f}, must sum to 1.0"

    if output_format == "json":
        scenario = {
            "scenario_name": name,
            "description": f"Test scenario for material system: {', '.join(material_distribution.keys())}",
            "particle_system": {
                "particle_count": particle_count,
                "material_distribution": {}
            },
            "lighting": {
                "preset": lighting_preset,
                "light_count": 13 if lighting_preset == "stellar_ring" else 5
            },
            "camera": {
                "position": [0.0, camera_distance * 0.3, camera_distance],
                "target": [0.0, 0.0, 0.0],
                "fov": 60.0
            },
            "rendering": {
                "shadow_quality": "balanced",
                "temporal_filtering": True,
                "volumetric_rt_samples": 8
            }
        }

        # Calculate particle counts for each material
        for material, percentage in material_distribution.items():
            count = int(particle_count * percentage)
            scenario["particle_system"]["material_distribution"][material] = {
                "count": count,
                "percentage": percentage * 100.0
            }

        return json.dumps(scenario, indent=2)

    elif output_format == "markdown":
        md = f"""# Test Scenario: {name}

## Overview
Particle Count: {particle_count:,}
Lighting Preset: {lighting_preset}
Camera Distance: {camera_distance:.1f} units

## Material Distribution

| Material Type | Count | Percentage |
|---------------|-------|------------|
"""
        for material, percentage in material_distribution.items():
            count = int(particle_count * percentage)
            md += f"| {material} | {count:,} | {percentage * 100:.1f}% |\n"

        md += f"""
## Lighting Configuration
- Preset: {lighting_preset}
- Expected lights: {'13 (Stellar Ring)' if lighting_preset == 'stellar_ring' else '5-16 lights'}

## Camera Setup
- Position: [0.0, {camera_distance * 0.3:.1f}, {camera_distance:.1f}]
- Target: [0.0, 0.0, 0.0]
- FOV: 60°

## Rendering Settings
- Shadow Quality: Balanced (4 rays/light)
- Temporal Filtering: Enabled (0.1 blend factor)
- Volumetric RT Samples: 8

## Expected FPS
- Target: 90-120 FPS @ 1080p on RTX 4060 Ti
- Material system overhead: ~5-8% (estimate)

## Validation Steps
1. Launch: `./build/Debug/PlasmaDX-Clean.exe --scenario={name}.json`
2. Wait 2-3 seconds for temporal convergence
3. Press F2 to capture screenshot
4. Run dxr-image-quality-analyst for visual assessment
5. Check logs for actual FPS and performance metrics
"""
        return md

    else:
        return f"❌ Error: Unknown output format '{output_format}'. Supported: json, markdown"


async def generate_imgui_controls(
    material_types: List[str],
    output_format: str = "cpp"
) -> str:
    """
    Generate ImGui control code for material property editing

    Args:
        material_types: List of material type names (e.g., ["PLASMA", "GAS_CLOUD", "STAR"])
        output_format: Output format (cpp, markdown)

    Returns:
        ImGui control code or documentation
    """

    if output_format == "cpp":
        code = f"""// Generated ImGui Material Controls
// Auto-generated by material-system-engineer
// Integrate into ImGui rendering loop

void RenderMaterialControls() {{
    if (ImGui::CollapsingHeader("Material System", ImGuiTreeNodeFlags_DefaultOpen)) {{

        // Material type selector
        static int currentMaterialType = 0;
        const char* materialTypes[] = {{
"""
        for mat in material_types:
            code += f'            "{mat}",\n'
        code += """        };

        if (ImGui::Combo("Material Type", &currentMaterialType, materialTypes, IM_ARRAYSIZE(materialTypes))) {
            // Material type changed - update preview/selection
        }

        ImGui::Separator();

        // Material properties (per-type editing)
        MaterialTypeProperties& mat = g_materialProperties[currentMaterialType];

        if (ImGui::SliderFloat("Opacity", &mat.opacity, 0.0f, 1.0f)) {
            // Opacity changed - update material buffer
        }

        if (ImGui::SliderFloat("Scattering Coefficient", &mat.scatteringCoefficient, 0.0f, 5.0f)) {
            // Scattering changed
        }

        if (ImGui::SliderFloat("Emission Multiplier", &mat.emissionMultiplier, 0.0f, 10.0f)) {
            // Emission changed
        }

        if (ImGui::ColorEdit3("Albedo (RGB)", &mat.albedo.x)) {
            // Albedo changed
        }

        if (ImGui::SliderFloat("Phase Function g", &mat.phaseG, -1.0f, 1.0f)) {
            // Phase function changed
            // g < 0: backward scattering (wispy gas)
            // g = 0: isotropic (uniform)
            // g > 0: forward scattering (dense dust)
        }

        ImGui::Separator();

        // Preset buttons
        if (ImGui::Button("Reset to Default")) {
            ResetMaterialToDefault(currentMaterialType);
        }

        ImGui::SameLine();
        if (ImGui::Button("Save Preset")) {
            SaveMaterialPreset(currentMaterialType);
        }

        ImGui::SameLine();
        if (ImGui::Button("Load Preset")) {
            LoadMaterialPreset(currentMaterialType);
        }

        // Material statistics
        ImGui::Separator();
        ImGui::Text("Material Statistics:");
        ImGui::Text("  Particle count: %d", GetParticleCountForMaterial(currentMaterialType));
        ImGui::Text("  Visible particles: %d", GetVisibleParticleCount(currentMaterialType));
        ImGui::Text("  Performance impact: %.1f%%", GetMaterialPerformanceImpact(currentMaterialType));
    }
}

/*
INTEGRATION INSTRUCTIONS:
1. Add to Application.h:
   void RenderMaterialControls();

2. Call in ImGui render loop:
   RenderMaterialControls();

3. Implement helper functions:
   - ResetMaterialToDefault(int materialType)
   - SaveMaterialPreset(int materialType)
   - LoadMaterialPreset(int materialType)
   - GetParticleCountForMaterial(int materialType)
   - GetVisibleParticleCount(int materialType)
   - GetMaterialPerformanceImpact(int materialType)
*/
"""
        return code

    elif output_format == "markdown":
        md = f"""# ImGui Material Controls

## Control Layout

### Material Type Selector
Dropdown menu for switching between material types:
"""
        for i, mat in enumerate(material_types):
            md += f"- {i}: {mat}\n"

        md += """
### Property Sliders

| Control | Range | Description |
|---------|-------|-------------|
| Opacity | 0.0 - 1.0 | Volumetric opacity (0=transparent, 1=opaque) |
| Scattering Coefficient | 0.0 - 5.0 | Volumetric scattering strength |
| Emission Multiplier | 0.0 - 10.0 | Temperature emission boost |
| Albedo (RGB) | Color picker | Surface/volume color |
| Phase Function g | -1.0 - 1.0 | Scattering direction bias |

### Phase Function Guide
- **g < 0** (Backward scattering): Wispy gas clouds, nebulae
- **g = 0** (Isotropic): Uniform scattering, general purpose
- **g > 0** (Forward scattering): Dense dust, smoke-like effects

### Preset Buttons
- **Reset to Default**: Restore original material properties
- **Save Preset**: Save current settings to JSON
- **Load Preset**: Load settings from JSON file

### Material Statistics Display
- Particle count for selected material
- Visible particle count (after culling)
- Performance impact percentage

## Usage Instructions
1. Select material type from dropdown
2. Adjust properties with sliders
3. Changes apply in real-time
4. Save successful configurations as presets
5. Press F2 to capture screenshot for visual validation
"""
        return md

    else:
        return f"❌ Error: Unknown output format '{output_format}'. Supported: cpp, markdown"


async def validate_file_syntax(
    file_path: str,
    file_content: str,
    file_type: str = "auto"
) -> str:
    """
    Basic syntax validation for generated code

    Args:
        file_path: File path (for error messages)
        file_content: File content to validate
        file_type: File type (auto, cpp, hlsl, json) - auto detects from extension

    Returns:
        Validation results with errors/warnings
    """

    # Auto-detect file type from extension
    if file_type == "auto":
        if file_path.endswith('.cpp') or file_path.endswith('.h'):
            file_type = "cpp"
        elif file_path.endswith('.hlsl'):
            file_type = "hlsl"
        elif file_path.endswith('.json'):
            file_type = "json"
        else:
            return f"⚠️ Warning: Unknown file type for {file_path}, skipping validation"

    errors = []
    warnings = []

    if file_type == "json":
        try:
            json.loads(file_content)
        except json.JSONDecodeError as e:
            errors.append(f"Line {e.lineno}: {e.msg}")

    elif file_type == "cpp":
        # Basic C++ syntax checks
        lines = file_content.split('\n')
        brace_count = 0
        paren_count = 0

        for i, line in enumerate(lines, start=1):
            brace_count += line.count('{') - line.count('}')
            paren_count += line.count('(') - line.count(')')

            # Check for common issues
            if ';;' in line:
                warnings.append(f"Line {i}: Double semicolon found")

            if line.strip().endswith('{') and not line.strip().startswith('//'):
                # Check opening brace style (personal preference check)
                pass

        if brace_count != 0:
            errors.append(f"Mismatched braces: {brace_count} unclosed")

        if paren_count != 0:
            errors.append(f"Mismatched parentheses: {paren_count} unclosed")

    elif file_type == "hlsl":
        # Basic HLSL syntax checks
        lines = file_content.split('\n')
        brace_count = 0

        for i, line in enumerate(lines, start=1):
            brace_count += line.count('{') - line.count('}')

            # Check for common HLSL issues
            if 'float3' in line and '=' in line and ',' in line.split('=')[1]:
                # Check for float3 initialization
                if line.count(',') < 2:
                    warnings.append(f"Line {i}: float3 initialization may be incomplete")

        if brace_count != 0:
            errors.append(f"Mismatched braces: {brace_count} unclosed")

    # Format results
    result = f"✅ Syntax Validation: {file_path}\n\n"
    result += f"File type: {file_type.upper()}\n"
    result += f"Lines: {len(file_content.split(chr(10)))}\n"
    result += f"Characters: {len(file_content):,}\n\n"

    if errors:
        result += "❌ ERRORS:\n"
        for error in errors:
            result += f"  - {error}\n"
        result += "\n"

    if warnings:
        result += "⚠️ WARNINGS:\n"
        for warning in warnings:
            result += f"  - {warning}\n"
        result += "\n"

    if not errors and not warnings:
        result += "✅ No syntax errors detected\n"
        result += "\n⚠️ Note: This is basic validation. Full compilation required for complete validation.\n"

    return result
