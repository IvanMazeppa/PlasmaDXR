"""
Code Generation Tools
Generate HLSL shaders, C++ structs, and material configs
"""

from typing import Dict, List, Optional


async def generate_material_shader(
    material_type: str,
    properties: Dict,
    base_shader_template: str = "volumetric_raytracing"
) -> str:
    """
    Generate complete HLSL shader code for material type

    Args:
        material_type: Material type (GAS_CLOUD, STAR_MAIN_SEQUENCE, etc.)
        properties: Material properties dict (opacity, scattering_coefficient, emission_multiplier, albedo_rgb, phase_function_g)
        base_shader_template: Shader template to use (volumetric_raytracing, billboard, hybrid)

    Returns:
        Complete HLSL shader code as string with material-specific logic
    """

    # Extract properties with defaults
    opacity = properties.get('opacity', 1.0)
    scattering = properties.get('scattering_coefficient', 1.0)
    emission = properties.get('emission_multiplier', 1.0)
    albedo = properties.get('albedo_rgb', [1.0, 1.0, 1.0])
    phase_g = properties.get('phase_function_g', 0.0)

    shader_code = f"""// Generated Material Shader: {material_type}
// Auto-generated by material-system-engineer
// Base template: {base_shader_template}

// Material-specific constants for {material_type}
static const float MATERIAL_{material_type}_OPACITY = {opacity}f;
static const float MATERIAL_{material_type}_SCATTERING = {scattering}f;
static const float MATERIAL_{material_type}_EMISSION = {emission}f;
static const float3 MATERIAL_{material_type}_ALBEDO = float3({albedo[0]}f, {albedo[1]}f, {albedo[2]}f);
static const float MATERIAL_{material_type}_PHASE_G = {phase_g}f;

// Material property lookup function
MaterialProperties Get{material_type}Properties()
{{
    MaterialProperties props;
    props.opacity = MATERIAL_{material_type}_OPACITY;
    props.scatteringCoefficient = MATERIAL_{material_type}_SCATTERING;
    props.emissionMultiplier = MATERIAL_{material_type}_EMISSION;
    props.albedo = MATERIAL_{material_type}_ALBEDO;
    props.phaseG = MATERIAL_{material_type}_PHASE_G;
    return props;
}}

// Material-specific ray marching behavior
float3 RayMarch{material_type}(
    RayDesc ray,
    float3 startPos,
    float3 endPos,
    float stepSize,
    Particle particle
)
{{
    MaterialProperties mat = Get{material_type}Properties();

    float3 accumulatedColor = float3(0, 0, 0);
    float transmittance = 1.0;

    float3 rayDir = normalize(endPos - startPos);
    float rayLength = length(endPos - startPos);
    int numSteps = int(rayLength / stepSize);

    for (int i = 0; i < numSteps; i++) {{
        float t = i * stepSize;
        float3 samplePos = startPos + rayDir * t;

        // Density calculation (Gaussian falloff)
        float distSq = dot(samplePos - particle.position, samplePos - particle.position);
        float density = exp(-distSq / (particle.radius * particle.radius));

        // Material-aware extinction
        float extinction = density * mat.opacity * mat.scatteringCoefficient;

        // Beer-Lambert law absorption
        float absorption = exp(-extinction * stepSize);
        transmittance *= absorption;

        // Emission contribution (temperature-based blackbody + material emission multiplier)
        float3 emission = ComputeBlackbodyEmission(particle.temperature) * mat.emissionMultiplier;

        // Scattering contribution (phase function-weighted)
        float3 scattering = mat.albedo * mat.scatteringCoefficient;

        // Accumulate color with transmittance weighting
        accumulatedColor += (emission + scattering) * (1.0 - absorption) * transmittance;

        // Early exit if fully opaque
        if (transmittance < 0.001) break;
    }}

    return accumulatedColor;
}}

/*
USAGE NOTES:
- Integrate Get{material_type}Properties() into material lookup table
- Call RayMarch{material_type}() in main ray tracing loop based on particle.materialType
- Adjust stepSize for quality/performance trade-off (0.1 = high quality, 0.5 = performance)
- Phase function g={phase_g}:
    g < 0: Backward scattering (wispy gas clouds)
    g = 0: Isotropic scattering (uniform)
    g > 0: Forward scattering (dense dust)
*/
"""

    return shader_code


async def generate_particle_struct(
    base_struct: str,
    new_fields: List[Dict],
    target_alignment: int = 16
) -> str:
    """
    Generate C++ particle struct with proper GPU alignment

    Args:
        base_struct: Existing struct definition (or "minimal" for new struct)
        new_fields: List of field dicts with 'type', 'name', 'size_bytes', 'comment'
        target_alignment: GPU alignment requirement (default: 16 bytes for DX12)

    Returns:
        Complete C++ struct definition with alignas and padding
    """

    # Calculate total size
    base_size = 32 if base_struct == "minimal" else 48  # Assume 48-byte current struct
    additional_size = sum(field['size_bytes'] for field in new_fields)
    total_size = base_size + additional_size

    # Calculate padding needed for alignment
    if total_size % target_alignment != 0:
        padding_bytes = target_alignment - (total_size % target_alignment)
    else:
        padding_bytes = 0

    aligned_size = total_size + padding_bytes

    struct_code = f"""// Generated Particle Structure
// Auto-generated by material-system-engineer
// Target alignment: {target_alignment} bytes
// Total size: {aligned_size} bytes

struct alignas({target_alignment}) Particle {{
    // === LEGACY FIELDS (32 bytes) - DO NOT REORDER ===
    DirectX::XMFLOAT3 position;       // 12 bytes (offset 0)
    float temperature;                // 4 bytes  (offset 12)
    DirectX::XMFLOAT3 velocity;       // 12 bytes (offset 16)
    float density;                    // 4 bytes  (offset 28)
"""

    if base_size > 32:
        struct_code += """
    // === PHASE 1 FIELDS (16 bytes) ===
    DirectX::XMFLOAT3 albedo;         // 12 bytes (offset 32)
    uint32_t materialType;            // 4 bytes  (offset 44)
"""

    # Add new fields
    if new_fields:
        struct_code += "\n    // === NEW FIELDS ===\n"
        current_offset = base_size
        for field in new_fields:
            struct_code += f"    {field['type']} {field['name']};"
            struct_code += f"  // {field['size_bytes']} bytes (offset {current_offset})"
            if 'comment' in field:
                struct_code += f" - {field['comment']}"
            struct_code += "\n"
            current_offset += field['size_bytes']

    # Add padding if needed
    if padding_bytes > 0:
        struct_code += f"\n    // === PADDING FOR ALIGNMENT ===\n"
        struct_code += f"    float padding[{padding_bytes // 4}];  // {padding_bytes} bytes padding\n"

    struct_code += f"""
}};  // Total: {aligned_size} bytes ({aligned_size // target_alignment} × {target_alignment}-byte aligned ✓)

// Compile-time size validation
static_assert(sizeof(Particle) == {aligned_size}, "Particle struct size mismatch!");
static_assert(alignof(Particle) == {target_alignment}, "Particle struct alignment mismatch!");

/*
INTEGRATION NOTES:
- Update ParticleSystem.h with this struct definition
- Update HLSL shader (gaussian_common.hlsl) with matching struct
- Recompile all shaders that use Particle struct
- Update buffer creation in ParticleSystem.cpp:
    size_t bufferSize = particleCount * sizeof(Particle);  // Now {aligned_size} bytes per particle
- GPU memory impact: {aligned_size - 32} bytes increase per particle
    @ 10K particles: {(aligned_size - 32) * 10000 // 1024} KB additional memory
    @ 100K particles: {(aligned_size - 32) * 100000 // 1024} KB additional memory
*/
"""

    return struct_code


async def generate_material_config(
    material_definitions: List[Dict],
    output_format: str = "json"
) -> str:
    """
    Generate material property configuration file

    Args:
        material_definitions: List of material dicts with type, opacity, scattering, emission, albedo, phaseG
        output_format: Output format (json, cpp_array, hlsl_constants)

    Returns:
        Formatted material configuration as string
    """

    if output_format == "json":
        import json

        config = {
            "version": "1.0",
            "description": "Material property definitions for PlasmaDX-Clean",
            "materials": {}
        }

        for mat in material_definitions:
            material_name = mat.get('type', 'UNKNOWN')
            config["materials"][material_name] = {
                "opacity": mat.get('opacity', 1.0),
                "scatteringCoefficient": mat.get('scattering_coefficient', 1.0),
                "emissionMultiplier": mat.get('emission_multiplier', 1.0),
                "albedo": {
                    "r": mat.get('albedo_rgb', [1.0, 1.0, 1.0])[0],
                    "g": mat.get('albedo_rgb', [1.0, 1.0, 1.0])[1],
                    "b": mat.get('albedo_rgb', [1.0, 1.0, 1.0])[2]
                },
                "phaseG": mat.get('phase_function_g', 0.0),
                "description": mat.get('description', '')
            }

        return json.dumps(config, indent=2)

    elif output_format == "cpp_array":
        code = """// Generated Material Properties Array
// Auto-generated by material-system-engineer

static const MaterialTypeProperties g_materialPresets[] = {
"""
        for i, mat in enumerate(material_definitions):
            albedo = mat.get('albedo_rgb', [1.0, 1.0, 1.0])
            code += f"""    {{  // {i}: {mat.get('type', 'UNKNOWN')}
        .albedo = DirectX::XMFLOAT3({albedo[0]}f, {albedo[1]}f, {albedo[2]}f),
        .opacity = {mat.get('opacity', 1.0)}f,
        .emissionMultiplier = {mat.get('emission_multiplier', 1.0)}f,
        .scatteringCoefficient = {mat.get('scattering_coefficient', 1.0)}f,
        .phaseG = {mat.get('phase_function_g', 0.0)}f
    }},
"""
        code += "};\n"
        return code

    elif output_format == "hlsl_constants":
        code = """// Generated Material Constants
// Auto-generated by material-system-engineer

"""
        for mat in material_definitions:
            mat_type = mat.get('type', 'UNKNOWN')
            albedo = mat.get('albedo_rgb', [1.0, 1.0, 1.0])
            code += f"""// {mat_type}
static const float3 ALBEDO_{mat_type} = float3({albedo[0]}f, {albedo[1]}f, {albedo[2]}f);
static const float OPACITY_{mat_type} = {mat.get('opacity', 1.0)}f;
static const float EMISSION_{mat_type} = {mat.get('emission_multiplier', 1.0)}f;
static const float SCATTERING_{mat_type} = {mat.get('scattering_coefficient', 1.0)}f;
static const float PHASE_G_{mat_type} = {mat.get('phase_function_g', 0.0)}f;

"""
        return code

    else:
        return f"❌ Error: Unknown output format '{output_format}'. Supported: json, cpp_array, hlsl_constants"
